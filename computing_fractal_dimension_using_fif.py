# -*- coding: utf-8 -*-
"""Computing Fractal Dimension using FIF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11qOkR9tO8lDm3kQFqC0NHY2U6eqru-9m

# Importing the files and libraries required
"""

#Upload both KSA east and west coastlines
from google.colab import files
files.upload()

import matplotlib.pyplot as plt
import numpy as np      
import pandas as pd
import itertools
import math
import random
from mpmath import power, fadd, fsub, fdiv,fmul, mpf, fabs, fsum, hypot
import heapq
import geopy.distance
import seaborn as sns

sns.set_style('darkgrid')

ksaDataFrame = pd.read_csv('ksa-east.csv')

ksaEast = pd.read_csv('ksa-east.csv')
ksaWest = pd.read_csv('ksa-west.csv')

len(ksaEast)

len(ksaWest)

"""# **Define classes for coordinates and Segment**"""

class CoOrdinates:
  def __init__(self, x, y):
    self.x = x
    self.y = y

class Segment:
  def __init__(self, segment, trend):
    self.segment = segment
    self.trend = trend

"""# **Split The Coordinates into monotonic trended Segments:**"""

def mergeFirstAndLastIfAllowed(segmentsList):
  firstSegment = segmentsList[0]
  lastSegment = segmentsList[-1]

  if firstSegment.trend == lastSegment.trend:
    increaseCase = firstSegment.trend == 'Increasing' and firstSegment.segment[-1].x > lastSegment.segment[0].x
    decreaseCase = firstSegment.trend == 'Decreasing' and firstSegment.segment[-1].x < lastSegment.segment[0].x
    if increaseCase or decreaseCase:
      firstSegment.segment = lastSegment.segment + firstSegment.segment
      segmentsList.pop()
  
  return segmentsList

def divideIntoSegments(ksaDataFrame):
  segmentsList = []
  currentSegment = []
  trend = 'Constant'

  for idx, row in ksaDataFrame.iterrows():
    x, y = row['X'], row['Y']

    if idx == 0:
      currentSegment.append(CoOrdinates(x,y))
      prevX = x
      continue
    
    breakingDecreasingTrend = (x >= prevX) and trend == 'Decreasing'
    breakingIncreasingTrend = (x <= prevX) and trend == 'Increasing'

    if breakingDecreasingTrend or breakingIncreasingTrend:
      copiedSegment = currentSegment.copy()
      segmentsList.append(Segment(copiedSegment, trend))
      trend = 'Constant'
      currentSegment = []
    
    elif x > prevX:
      trend = 'Increasing'
    
    else:
      trend = 'Decreasing'
    
    currentSegment.append(CoOrdinates(x,y))
    prevX = x
  
  
  if trend != 'Constant':
    copiedSegment = currentSegment.copy()
    segmentsList.append(Segment(copiedSegment, trend))

  segmentsList = mergeFirstAndLastIfAllowed(segmentsList)

  return segmentsList

segmentsList = divideIntoSegments(ksaDataFrame)

"""# Is Monotonic (Tester Function for splitting the segement)"""

def isMonotonic(segment, trend):
  for i in range(1, len(segment)):
    if trend == 'Increasing':
      if segment[i].x < segment[i-1].x:
        return False
    
    if trend == 'Decreasing':
      if segment[i].x > segment[i-1].x:
        return False

  return True

"""# **Distance between Two Points**"""

def distanceBetweenTwoPoints(p1, p2):
  return math.sqrt(((p1.x-p2.x)** 2) + ((p1.y-p2.y)** 2))

"""# **Merge two decreasing Trended Segments by eliminating the points in the middle**"""

# Distance Matrix
def minDistanceRemovedDecreasing(segment1, segment2):
  n,m = len(segment1), len(segment2)

  distanceMatrix = [[0 for _ in range(m)] for _ in range(n)]

  for i in range(n):
    for j in range(m-1, -1, -1):
      if i == 0 or j == m-1:
        continue
      
      if segment1[i].x > segment2[j].x:
        distanceMatrix[i][j] = 0
      
      else:
        #Remove End from Segment1
        ch1 = distanceMatrix[i-1][j] + distanceBetweenTwoPoints(segment1[i-1], segment1[i])

        #Remove Start from Segment2
        ch2 = distanceMatrix[i][j+1] + distanceBetweenTwoPoints(segment2[j], segment2[j+1])


        distanceMatrix[i][j] = min(ch1, ch2)
  
  return distanceMatrix

"""# **Merge two Increasing Trended Segments by eliminating the points in the middle**"""

# Distance Matrix Increasing
def minDistanceRemovedIncreasing(segment1, segment2):
  n,m = len(segment1), len(segment2)

  distanceMatrix = [[0 for _ in range(m)] for _ in range(n)]

  for i in range(n):
    for j in range(m-1, -1, -1):
      if i == 0 or j == m-1:
        continue
      
      if segment1[i].x < segment2[j].x:
        distanceMatrix[i][j] = 0
      
      else:
        #Remove End from Segment1
        ch1 = distanceMatrix[i-1][j] + distanceBetweenTwoPoints(segment1[i-1], segment1[i])

        #Remove Start from Segment2
        ch2 = distanceMatrix[i][j+1] + distanceBetweenTwoPoints(segment2[j], segment2[j+1])


        distanceMatrix[i][j] = min(ch1, ch2)
  
  return distanceMatrix

"""# **BackTrack after Building the distance Matrix**"""

def backTrack(distanceMatrix):
  n = len(distanceMatrix)
  m = len(distanceMatrix[0])

  i, j = n-1, 0

  while True:
    if distanceMatrix[i][j] == 0:
      if i == 0: i-=1
      if j == m-1: j+=1

      return (i, j)

    poss1, poss2 = [float('inf')]*2

    poss1 = distanceMatrix[i-1][j]
    poss2 = distanceMatrix[i][j+1]

    if poss1 < poss2:
      i-=1
    else:
      j+=1

"""# **Merge Possible Segments and get New Segments List**"""

def mergePossibleSegments(segmentsList, mergeFactor):
  newSegmentsList = []


  currentSegment = segmentsList[0].segment
  currentTrend = segmentsList[0].trend

  for i in range(1, len(segmentsList)):
    segment = segmentsList[i].segment
    trend = segmentsList[i].trend

    if trend == currentTrend:
      if trend == 'Decreasing':
        distanceMatrix = minDistanceRemovedDecreasing(currentSegment, segment)
      
      elif trend == 'Increasing':
        distanceMatrix = minDistanceRemovedIncreasing(currentSegment, segment)

      if distanceMatrix[-1][0] < mergeFactor:
        endIdx, startIdx = backTrack(distanceMatrix)
        currentSegment = currentSegment[:endIdx+1] + segment[startIdx:]
        continue
      
    newSegmentsList.append(Segment(currentSegment, currentTrend))
    currentSegment = segment
    currentTrend = trend
  
  newSegmentsList.append(Segment(currentSegment, currentTrend))

  return newSegmentsList

newSegments = mergePossibleSegments(segmentsList, 300)

"""# Delete Segments whose distance is less than distance Parameter and length is less than minLength"""

def distanceOfSegment(segment):
  distance = 0
  for i in range(1, len(segment)):
    distance += distanceBetweenTwoPoints(segment[i], segment[i-1])
  
  return distance

# Ignore Small segments whose distance is less than the distance parameter
def ignoreSmallSegments(segmentsList, distanceParameter, minLength):
  newSegmentsList = []

  for segment in segmentsList:
    if len(segment.segment) >= minLength and distanceOfSegment(segment.segment) > distanceParameter:
      newSegmentsList.append(segment)
  
  return newSegmentsList

segmentsListAfterIgnoringSmallSegments = ignoreSmallSegments(newSegments, 50, 10)

print(len(segmentsListAfterIgnoringSmallSegments))

"""# Merge Again"""

newSegmentsOne = mergePossibleSegments(segmentsListAfterIgnoringSmallSegments, 300)

print(len(newSegmentsOne))

"""# Pack Everything

1. Given the dataFrame of co-ordinates, split into monotonic trended segments
2. Merge segments with removed Distance less than merge Factor.
3. Delete Segments with distance less than the distance parameter.
4. Merge the new  segments list again.
5. Return the final segments list for use.
"""

def finalSegmentsList(dataFrame, mergeFactor, distanceFactor, minLength):
  dividedSegments = divideIntoSegments(dataFrame)
  firstMergeSegments = mergePossibleSegments(dividedSegments, mergeFactor)
  listWithDeletedSegments = ignoreSmallSegments(firstMergeSegments, distanceFactor, minLength)
  # secondMergeSegments = mergePossibleSegments(listWithDeletedSegments, mergeFactor)

  return listWithDeletedSegments

def getFinalRawSegmentsList(segmentsList):
  rawList = []

  for segment in segmentsList:
    if segment.trend == 'Decreasing':
      rawList.append(segment.segment[::-1])
    else:
      rawList.append(segment.segment)
  
  return rawList

def lengthAnalysis(segmentsList):
  lengthHash = {}
  for i in range(len(segmentsList)):
    currlen = len(segmentsList[i])
    if currlen in lengthHash:
      lengthHash[currlen]+=1
    
    else:
      lengthHash[currlen] = 1
  
  for i in sorted(lengthHash.keys()):
    print(i, lengthHash[i])

"""# Get Final KSA east and west lists (MERGED)"""

ksaWestList = getFinalRawSegmentsList(finalSegmentsList(ksaWest, 300, 300, 20))
ksaEastList = getFinalRawSegmentsList(finalSegmentsList(ksaEast, 300, 300, 20))

len(ksaWestList)

len(ksaEastList)

lengthAnalysis(ksaWestList)

lengthAnalysis(ksaEastList)

eastAndWestList = ksaEastList+ ksaWestList
len(eastAndWestList)

"""## Fractal Dimension

# Get a,b,c,d lists for FIF method
"""

'''
Get the ai values of the IFS
'''
def getAValues(segment):
  aValues = []
  xn = segment[-1].x
  xo = segment[0].x

  denominator = fsub(xn, xo)

  for i in range(1,len(segment)):
    xi = segment[i].x
    xi1 = segment[i-1].x

    numerator = fsub(xi, xi1)

    ai = fdiv(numerator, denominator)

    aValues.append(ai)
  
  return aValues

def getBValues(n):
  return [0 for _ in range(n)]

def getCValues(segment, dValues):
  cValues = []
  xn = segment[-1].x
  xo = segment[0].x
  fn = segment[-1].y
  fo = segment[0].y

  fno = fsub(fn, fo)

  denominator = fsub(xn, xo)

  for i in range(1, len(segment)):
    fi = segment[i].y
    fi1 = segment[i-1].y

    dn = dValues[i-1]

    numerator1 = fsub(fi, fi1)
    numerator2 = fmul(dn, fno)

    numerator = fsub(numerator1, numerator2)

    cValues.append(fdiv(numerator, denominator))
  
  return cValues

def getDValues(n):
  dValues = [0.9, 0.1]

  for i in range(n-2):
    dValues.append(0.0006)
  
  return dValues

def getEValues(segment):
  eValues = []
  xn = segment[-1].x
  xo = segment[0].x

  denominator = fsub(xn, xo)

  for i in range(1,len(segment)):
    xi = segment[i].x
    xi1 = segment[i-1].x

    numerator1 = fmul(xi1, xn)
    numerator2 = fmul(xo, xi)

    numerator = fsub(numerator1, numerator2)

    eValues.append(fdiv(numerator, denominator))

  return eValues

def getFValues(segment, dValues):
  fValues = []
  xn = segment[-1].x
  xo = segment[0].x
  fn = segment[-1].y
  fo = segment[0].y


  denominator = fsub(xn, xo)


  num20 = fmul(xn, fo)
  num21 = fmul(xo, fn)
  num2 = fsub(num20, num21)

  for i in range(1, len(segment)):
    fi = segment[i].y
    fi1 = segment[i-1].y
    
    num10 = fmul(xn, fi1)
    num11 = fmul(xo, fi)
    num1 = fsub(num10, num11)

    dn = dValues[i-1]
    
    finalNum2 = fmul(dn, num2)

    numerator = fsub(num1, finalNum2)

    fValues.append(fdiv(numerator, denominator))
  
  return fValues

"""# Optimal d Values using Analytical Method from Paper Using IFS to model discrete sequences (Experimental for now, Not finished)


"""

def getMValues(segment):
  aValues = getAValues(segment)
  eValues = getEValues(segment)

  mValues = []
  for i in range(len(segment)-1):
    nValue = (int(fadd(fmul(aValues[i], i), eValues[i]))) % (len(segment)-1)
    mValues.append(nValue)

  return mValues

def getEpsilonNValues(segment):
  epsilonNValues = []
  xn = segment[-1].x
  x0 = segment[0].x

  denominator = fsub(xn, x0)

  for i in range(1, len(segment)):
    xi = segment[i].x
    numerator = fsub(xn, xi)
    epsilonValue = fdiv(numerator, denominator)
    epsilonNValues.append(epsilonValue)
  
  return epsilonNValues

def getANValues(segment,epsilonNValues):
  ANValues = []
  y0 = segment[0].y
  yn = segment[-1].y
  
  for i in range(len(segment)-1):
    yi = segment[i].y
    part21 = fmul(epsilonNValues[i], y0)
    part221 = fsub(1, epsilonNValues[i])
    part22 = fmul(part221, yn)

    part2 = fadd(part21, part22)

    ANValues.append(fsub(yi, part2))
  
  return ANValues

def getBNValues(segment, epsilonNValues, idx, aValues, eValues):
  y1 = segment[idx].y
  y2 = segment[idx+1].y

  BNValues = []
  mValues = getMValues(segment)

  for i in range(len(segment)-1):
    m = mValues[i]
    ym = segment[m].y
    part21 = fmul(epsilonNValues[i], y1)
    part221 = fsub(1, epsilonNValues[i])
    part22 = fmul(part221, y2)
    part2 = fadd(part21, part22)

    BNValues.append(fsub(ym, part2))
  
  return BNValues

def getSumOfASquares(ANValues):
  result = 0
  for i in range(len(ANValues)):
    result = fadd(result, fmul(ANValues[i], ANValues[i]))
  
  return result

def getSumOfANBN(ANValues, BNValues):
  result = 0
  for i in range(len(ANValues)):
    result = fadd(result, fmul(ANValues[i], BNValues[i]))
  
  return result

def getOptimalDValuesAnalytical(segment):
  epsilonNValues = getEpsilonNValues(segment)
  ANValues = getANValues(segment,epsilonNValues)

  sumOfASquares = getSumOfASquares(ANValues)

  dValues = []

  aValues = getAValues(segment)
  eValues = getEValues(segment)

  for i in range(len(segment)-1):
    BNValues = getBNValues(segment, epsilonNValues, i, aValues, eValues)
    sumOfANBN = getSumOfANBN(ANValues, BNValues)

    dValues.append(fdiv(sumOfANBN,sumOfASquares))
  
  return dValues

"""# Optimal d Values using Geometric Method from Paper Using IFS to model discrete sequences (Experimental for now, Not finished)"""

def getA(x1, y1, x2, y2):
  numerator = fsub(y2, y1)
  denominator = fsub(x2, x1)

  if int(denominator) == 0:
    return (1, True)

  return (fdiv(numerator, denominator), False)

def getC(x1, y1, a):
  part2 = fmul(a, x1)

  return fsub(y1, part2)

def getNumerator(a, b, c, x0, y0):
  part1 = fmul(a, x0)
  part2 = fmul(b, y0)

  result = fsum([part1, part2, c])

  return fabs(result)

def getDistanceBwLineAndPoint(point, point1, point2):
  x0, y0 = point.x, point.y
  x1, y1 = point1.x, point2.y
  x2, y2 = point2.x, point2.y

  a = getA(x1, y1, x2, y2)
  b = 0 if a[1] else -1
  c = getC(x1, y1, a[0])

  denominator = hypot(a[0], 1)
  numerator = getNumerator(a[0], b, c, x0, y0)

  return fdiv(numerator, denominator)

def getMue(segment):
  mue = 0
  point1 = segment[0]
  point2 = segment[-1]

  for i in range(1, len(segment)-1):
    vDistance = getDistanceBwLineAndPoint(segment[i], point1, point2)
    mue = max(mue, vDistance)
  
  return mue

def getV(segment, idx):
  v = 0

  point1 = segment[idx]
  point2 = segment[idx+1]

  for i in range(len(segment)):
    if i == idx or i == idx+1:
      continue
    
    vDistance = getDistanceBwLineAndPoint(segment[i], point1, point2)
    v = max(v, vDistance)
  
  return v

def getOptimalDValues(segment):
  mue = getMue(segment)
  dValues = []

  for idx in range(len(segment)-1):
    v = getV(segment, idx)
    dValues.append(fdiv(v, mue))
  
  return dValues

"""# Fractal Dimension Expression/ Equation"""

def fdExpression(aValues, dValues, D):
  expressionResult = 0

  for i in range(len(aValues)):
    aRaised = power(aValues[i], D-1)

    dMulA = fmul(dValues[i], aRaised)

    expressionResult = fadd(expressionResult, dMulA)
  
  return expressionResult

"""# Find Fractal Dimension D Using Binary Search Algorithm"""

def findDBinarySearch(segment):
  aValues = getAValues(segment)
  dValues = getDValues(len(segment)-1)


  left, right = 1, 2


  while True:

    mid = fdiv(fadd(left, right), 2)

    fdExpressionValue = fdExpression(aValues, dValues, mid)

    if abs(fdExpressionValue-1) < power(10,-10):
      return mid

    if fdExpressionValue > 1:
      left = mid
    
    else:
      right = mid
    
    if mid == 1 or mid == 2: return 'No solution'

    # print(mid, fdExpressionValue)

def plotGraph(segment, plotTitle):
  xValues = []
  yValues = []

  for point in segment:
    xValues.append(point.x)
    yValues.append(point.y)
  
  plt.figure(figsize=(8,4.8))
  plt.plot(xValues, yValues)
  plt.title(plotTitle + '     Length: ' + str(len(xValues)))
  plt.xticks([])
  plt.yticks([])
  plt.show()
  # plt.savefig(plotTitle + '.png')

def plotGraphKsa(dataFrame, plotTitle):
  xValues = []
  yValues = []

  for idx, row in dataFrame.iterrows():
    xValues.append(row['X'])
    yValues.append(row['Y'])

  plt.figure(figsize=(10, 10), tight_layout=True)
  plt.plot(xValues, yValues)
  plt.title(plotTitle + 'Length: ' + str(len(xValues)))
  plt.xticks([])
  plt.yticks([])
  plt.show()
  plt.savefig(plotTitle + '.png')

"""# Maximum Fractal Dimension among subdivisions"""

maximumFractalDimension = 0
for i in range(len(eastAndWestList)):
  d = findDBinarySearch(eastAndWestList[i])
  maximumFractalDimension = max(maximumFractalDimension, d)

print(maximumFractalDimension)

"""# Random Iteration Algoithm"""

def getPValues(n):
  average = 1/n

  last = 1 - ((n-1)*average)

  pValues = []

  for _ in range(n-1):
    pValues.append(average)
  
  pValues.append(last)

  return pValues

def randomIteration(segment, iters, segmentNumber):
  n = len(segment)-1

  a = getAValues(segment)
  d = getDValues(n)
  b = getBValues(n)
  c = getCValues(segment, d)
  e = getEValues(segment)
  f = getFValues(segment, d)
  p = getPValues(n)

  x = np.linspace(0,5,500)
  y = np.linspace(0,5,500)

  initial = []

  for x,y in zip(x,y):
    initial.append([0,y])
    initial.append([n,y])
    initial.append([x,0])
    initial.append([x,n])

  initial = np.array(initial)

  fig = plt.figure(figsize=(10,10))

  j=0

  for i in range(iters):
    temp = []
    
    for x,y in initial:
      rnd = np.random.choice([i for i in range(n)], p=p)
      nx = a[rnd]*x+b[rnd]*y+e[rnd]
      ny = c[rnd]*x+d[rnd]*y+f[rnd]
      temp.append([nx,ny])

    initial = np.array(temp)


  x,y = initial[:,0],initial[:,1]

  plt.figure(figsize=(8,4.8))
  plt.scatter(x, y, s=1)
  plt.title('Attractor Generated by Random Iteration For segment' + str(segmentNumber))
  plt.xticks([])
  plt.yticks([])
  plt.show()

for i in range(len(eastAndWestList)):
  plotGraph(eastAndWestList[i], 'segment '+ str(i))

plotGraph(eastAndWestList[0], 'segment '+ str(0))
findDBinarySearch(eastAndWestList[0])

i = 672
plotGraph(eastAndWestList[i], 'segment '+ str(i))
findDBinarySearch(eastAndWestList[i])

"""# Calculating Hausdorff distance (Future Extension, Irrelevant for Now)"""

def distanceBetweenTwoPoints1(p1, p2):
  return math.sqrt(((p1.x-p2.x)** 2) + ((p1.y-p2.y)** 2))

def getDistanceBetweenPointAndSet(point, setB):
  distanceBetweenPointAndSet = float('inf')

  for secondPoint in setB:
    distanceBetweenPointAandB = distanceBetweenTwoPoints1(point, secondPoint)
    distanceBetweenPointAndSet = min(distanceBetweenPointAndSet,distanceBetweenPointAandB)
  return distanceBetweenPointAndSet

def getDistanceBetweenSetAandB(setA, setB):
  distanceBetweenSetAandB = -float('inf')
  for point in setA:
    distanceBetweenPtToSetB = getDistanceBetweenPointAndSet(point, setB)
    distanceBetweenSetAandB = max(distanceBetweenSetAandB,distanceBetweenPtToSetB)
  return distanceBetweenSetAandB

def getHausdorffDistance(setA, setB):
  setAtoB = getDistanceBetweenSetAandB(setA, setB)
  setBtoA = getDistanceBetweenSetAandB(setB, setA)

  return (setAtoB, setBtoA)

"""# First Order Transformation of Set by IFS (Future Extension, Irrelevant for Now)"""

def getWnTransformation(pt, a, c, d, e, f, n):
  ptX, ptY = pt.x, pt.y
  an, cn, dn, en, fn = a[n], c[n], d[n], e[n], f[n]

  newX = (an*ptX) + en
  newY = ((cn*ptX)+ (dn*ptY))+ fn

  return CoOrdinates(newX, newY)

def getFirstOrderTransformationByIFS(setA, a, c, d, e, f):
  finalSet = []
  for pt in setA:
    for idx in range(len(a)):
      wnTransformation = getWnTransformation(pt, a, c, d, e, f, idx)
      finalSet.append(wnTransformation)
  return finalSet

"""# Distance Between Set and first order transformation of set By IFS (Future Extension, Irrelevant for Now)

"""

def getHausdorffDistanceBetweenSetAndFirstOrderTransformationOnIFS(setA, a, c, d, e, f):
  setB = getFirstOrderTransformationByIFS(setA, a, c, d, e, f)
  return getHausdorffDistance(setA, setB)

"""# Get Attractor Of IFS formed by giving Segment as an input (Future Extension, Irrelevant for Now)"""

def getAttractor(segment, iters):
  n = len(segment)-1

  a = getAValues(segment)
  d = getDValues(n)
  c = getCValues(segment, d)
  e = getEValues(segment)
  f = getFValues(segment, d)
  p = getPValues(n)

  initial = []


  initial+= segment
  initial = np.array(initial)

  for i in range(iters):
    temp = []
    
    for point in initial:
      x, y = point.x, point.y
      rnd = np.random.choice([i for i in range(n)], p=p)
      nx = a[rnd]*x +e[rnd]
      ny = c[rnd]*x+d[rnd]*y+f[rnd]
      temp.append(CoOrdinates(nx, ny))

    initial = np.array(temp)
  
  return initial

"""# Distance Between Attractor and Set (Future Extension, Irrelevant for Now)"""

def getDistanceBetweenAttractorAndSet(segment, iterations):
  attractor = getAttractor(segment, iterations)
  return getDistanceBetweenSetAandB(segment, attractor)

print(getDistanceBetweenAttractorAndSet(eastAndWestList[0], 0))

print(getDistanceBetweenSetAandB(eastAndWestList[0], eastAndWestList[0]))

for i in range(0,10000, 100):
  print(getDistanceBetweenAttractorAndSet(eastAndWestList[0], i))

print(getDistanceBetweenAttractorAndSet(eastAndWestList[0], 10000))

for i in range(5000,11001, 2000):
  print(getDistanceBetweenAttractorAndSet(eastAndWestList[0], i))

a = getAValues(eastAndWestList[0])
d = getDValues(len(eastAndWestList[0])-1)
c = getCValues(eastAndWestList[0], d)

e = getEValues(eastAndWestList[0])
f = getFValues(eastAndWestList[0], d)

print(getHausdorffDistanceBetweenSetAndFirstOrderTransformationOnIFS(eastAndWestList[0], a, c, d, e, f))

print(getHausdorffDistanceBetweenSetAndFirstOrderTransformationOnIFS(eastAndWestList[0], a, c, d, e, f))